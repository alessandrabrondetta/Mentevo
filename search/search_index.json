{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>\ud83d\udc4b  Mentevo is a compact library designed for studying the dynamic of balancing cognitive stability and flexibility in groups of agents, initially providing the implementation code for the research paper of Brondetta et al, 2023.</p> <p>This repository also introduces various parametrization, visualization methods as well as metrics to compute performances of each agents. However, Mentevo emphasizes experimentation and is not an official reproduction of any other paper aside from Brondetta et al.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To start with Mentevo, we propose multiple notebook that will help you familiarize with the library</p> <ul> <li>Starter Notebook </li> <li>Study of optimal gain value depending on the task switching rate </li> <li>Performance in details </li> <li>Partially informed agents </li> </ul> <p>Otherwise, you can simply start hacking with mentevo, it's as simple as:</p> <pre><code>from mentevo import (Experiment, compute_performance, plot_curves)\n\n# create an experiment object\nexperiment = Experiment(nb_agents=4)\nsimulation_results = experiment.solve()\n\n# plots the simulation results\nplot_curves(experiment, simulation_results)\n\n# compute the performance\nscores = compute_performance(experiment, simulation_results)\nprint('individual performance', scores[0])\nprint('group performance', scores[1])\n</code></pre> <p>When optimizing, it's crucial to fine-tune the hyperparameters. Parameters like the alpha, beta, d or tau significantly impact the output. We recommend ajusting the values according to the original paper to ensure comparable results.</p>"},{"location":"#citation","title":"Citation","text":"<pre><code>@inproceedings{brondetta2024benefits,\n  title={On the Benefits of Heterogeneity in Cognitive Stability and Flexibility for Collaborative Task Switching},\n  author={Brondetta, Alessandra and Bizyaeva, Anastasia and Lucas, Maxime and Petri, Giovanni and Musslick, Sebastian},\n  booktitle={Proceedings of the Annual Meeting of the Cognitive Science Society},\n  volume={46},\n  year={2024}\n}\n</code></pre>"},{"location":"#authors","title":"Authors","text":"<ul> <li>Alessandra Brondetta - alessandra.brondetta@uni-osnabrueck.de, Candidate PhD Student, Osnabr\u00fcck University</li> </ul>"},{"location":"experiments/","title":"Experiment","text":"<p>You can write text here.</p> <pre><code>this is some python cooode\n</code></pre> <p>Todo this documentation</p>"},{"location":"experiments/#Experiment","title":"<code>Experiment</code>","text":"<p>Class to represent an experiment. This Experiment class models and simulates a system with  interacting agents and tasks, solving a nonlinear dynamical system defined by agent behaviors,  communication structure and task correlations, system parameters and external inputs. The Experiment class simulates the evolution of the task activities of the agents over time, and is also defined by the initial state of the system and the parameters of the  simulation, such as total time of the simulation and number of task switches.  The class contains a solver for simulating system evolution over time. </p>"},{"location":"experiments/#__init__","title":"<code>__init__(self,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 number_of_agents=4,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 number_of_tasks=2,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 communication_graph=None,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 task_graph=None,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 alpha=0.03,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 beta=0.01,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 gamma=0.02,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 delta=0.0,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 d=0.2,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 tau=10.0,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 g=None,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 bias_value=0.1,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 initial_state=None,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 total_time=2000,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 initial_steps=0,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 reverse=False,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 number_of_switches=4,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 number_of_informed=None)</code>","text":"<p>Parameters</p> <ul> <li> <p>number_of_agents            : int, optional </p> <ul> <li><p> Number of agents in the system. Must be greater than 0. Default is 4. </p> </li> </ul> </li> <li> <p>number_of_tasks            : int, optional </p> <ul> <li><p> Number of tasks the agents have to perform. Must be greater than 0. Default is 2.</p> </li> </ul> </li> <li> <p>communication_graph            : 2D numpy array, optional </p> <ul> <li><p> The graph between agents. A positive value means that the agents have a positive interaction,  a negative value means that the agents have a negative interaction. A null value means that  the agents can not communicate.    Typically, the diagonal is 1 (intra-agent-communication).</p><p> If None, then the default is a fully connected graph where all agents can communicate.</p><p> The shape of the matrix is (number_of_agents, number_of_agents).</p> </li> </ul> </li> <li> <p>task_graph            : 2D numpy array, optional </p> <ul> <li><p> The graph between tasks. A positive value means that the tasks are positively correlated,  a negative value means that the tasks are negatively correlated. A null value means that  the tasks are not correlated.</p><p> Typically, the diagonal is 1 (same-task correlation).  If None, then the default is diagonal 1 (positive self correlation) and  off-diagonal values are -1 (negative correlations with the other tasks).</p><p> The shape of the matrix is (number_of_tasks, number_of_tasks). </p> </li> </ul> </li> <li> <p>alpha            : float, optional </p> <ul> <li><p> Parameter of the dynamical system's equations that represents the weight of the same agent- same task interactions. Must be greater than or equal to 0. Default is 0.03.  </p> </li> </ul> </li> <li> <p>beta            : float, optional </p> <ul> <li><p> Parameter of the dynamical system's equations that represents the weight of the same agent- different task interactions. Must be greater than or equal to 0. Default is 0.01. </p> </li> </ul> </li> <li> <p>gamma            : float, optional </p> <ul> <li><p> Parameter of the dynamical system's equations that represents the weight of the different agent- same task interactions. Must be greater than or equal to 0. Default is 0.02. </p> </li> </ul> </li> <li> <p>delta            : float, optional </p> <ul> <li><p> Parameter of the dynamical system's equations that represents the weight of the different agent- different task interactions. Must be greater than or equal to 0. Default is 0.0. </p> </li> </ul> </li> <li> <p>d            : float, optional </p> <ul> <li><p> Parameter of the dynamical system's equations that represents the weight of the decay term.</p><p> Must be greater than or equal to 0. Default is 0.2.    </p> </li> </ul> </li> <li> <p>tau            : float, optional </p> <ul> <li><p> Parameter of the dynamical system's equations that represents the time constant.  Must be greater than 0. Default is 10.0.</p> </li> </ul> </li> <li> <p>g            : 1D numpy array, optional </p> <ul> <li><p> The g vector of the dynamical system's equations, representing the gain values of the agents  and regulating the slope of the saturation function.  The shape of the array is (number_of_agents,).</p><p> Default is a gaussian vector with mean 3.0 and standard deviation 1.0. </p> </li> </ul> </li> <li> <p>bias_value            : float, optional </p> <ul> <li><p> The bias value of the dynamical system's equations that represents the weight of the cue  vector of the experiment. Must be greater than or equal to 0. Default is 0.1.</p> </li> </ul> </li> <li> <p>initial_state            : 1D numpy array, optional </p> <ul> <li><p> The initial state of the system, representing the task activity states at the start of the experiment. The shape of the array is (number_of_agents*number_of_tasks,).</p><p> Default is an array of zero for all agents on all tasks.</p> </li> </ul> </li> <li> <p>total_time            : int, optional </p> <ul> <li><p> The total time of the simulation in time units. Must be greater than 0. Default is 2_000. </p> </li> </ul> </li> <li> <p>initial_steps            : int, optional </p> <ul> <li><p> The number of initial steps in the experiment, where the agents don't receive the task cue.  Must be greater than or equal to 0. Must be less than total_time. Default is 0.</p> </li> </ul> </li> <li> <p>reverse            : bool, optional </p> <ul> <li><p> If True, the task cue vector is reversed in the experiment. Default is False.</p> </li> </ul> </li> <li> <p>number_of_switches            : int, optional </p> <ul> <li><p> The number of task switches in the experiment. Must be greater than or equal to 0.  Must be less than or equal to total_time. Must be greater than or equal to 0. Default is 4.</p> </li> </ul> </li> <li> <p>number_of_informed            : int, optional </p> <ul> <li><p> The number of agents that are informed in the experiment (agents that receive the task cue vector). Must be less than or equal to number_of_agents and non-negative.</p><p> Default is number_of_agents. </p> </li> </ul> </li> </ul>"},{"location":"experiments/#solve","title":"<code>solve(self,\u00a0\u00a0\u00a0\u00a0\u00a0 **kwargs)</code>","text":"<p>Solve the dynamical system defined by the experiment's parameters and initial state.  The system is solved using the scipy solve_ivp function. The system is solved for the total time of the experiment, with a maximum step of 1_000 and using the Radau  integration method. The system is solved for each time unit, and the task activity states of the agents are returned over time in the experiment. </p> <p>Parameters</p> <ul> <li> <p>kwargs            : dictionary, optional </p> <ul> <li><p> Additional keyword arguments to pass to the solve_ivp function.</p> </li> </ul> </li> </ul> <p>Return</p> <ul> <li> <p>zs.y            : 2D numpy array </p> <ul> <li><p> The task activity states of the agents over time in the experiment.</p><p> The shape of the array is (number_of_agents*number_of_tasks, total_time).</p> </li> </ul> </li> </ul> <p></p>"},{"location":"performance/","title":"Performance","text":"<p>You can write text here.</p> <pre><code>this is some python cooode\n</code></pre> <p>Todo this documentation</p>"},{"location":"performance/#compute_performance","title":"<code>compute_performance(experiment,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 simulation_results,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 detailed=False)</code>","text":"<p>Compute the performance of the agents in the experiment using the simulation results. The metric used is the dot product between the sign of cue vector and the simulation results,  which is the score of the agent. This means counting in a positive way the areas where the agent  is focusing more on the correct task and in a negative way the areas where the agent is  doing the wrong task. The group performance is simply the sum of the scores of all agents. </p> <p>Parameters</p> <ul> <li> <p>experiment            : Experiment </p> <ul> <li><p> The experiment object that generated the simulation_results.</p> </li> </ul> </li> <li> <p>simulation_results            : 2D numpy array </p> <ul> <li><p> The simulation results used to compute the performance.  The shape should be (number_of_agents * number_of_tasks, total_time).</p> </li> </ul> </li> <li> <p>detailed            : bool, optional </p> <ul> <li><p> Whether to return detailed information about the performance (performance values at each time step). The default is False.</p> </li> </ul> </li> </ul> <p>Return</p> <ul> <li> <p>individual_performance            : 1D numpy array </p> <ul> <li><p> The performance of each agent. The shape is (number_of_agents,).</p> </li> </ul> </li> <li> <p>group_performance            : float </p> <ul> <li><p> The performance of the group.</p> </li> </ul> </li> <li> <p>detailed_score            : 2D numpy array </p> <ul> <li><p> The performance of each agent, at each time step, on each task.  The shape is (total_time, number_of_agents*number_of_tasks).</p><p> This is returned only if detailed=True.     </p> </li> </ul> </li> </ul> <p></p>"}]}